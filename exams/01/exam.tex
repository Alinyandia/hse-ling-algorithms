\documentclass[12pt,answers]{exam}


\usepackage{cmap, type1ec}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{hyperref}
\usepackage{alltt}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amssymb}
\usepackage{multicol}
\usepackage{etoolbox}

\usepackage{tikz}
\usetikzlibrary{trees}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{positioning}

\newtoggle{first}
\toggletrue{first}
\togglefalse{first}

\newcommand{\class}{Теория алгоритмов}
\newcommand{\term}{Весенний семестр 2017}
\newcommand{\examnum}{Тест \#1~~Вариант \#\iftoggle{first}{1}{2}}
\newcommand{\examdate}{21 апреля 2017}
\newcommand{\timelimit}{\iftoggle{first}{15:10 -- 16:30}{16:40 -- 18:00}}

\pagestyle{head}
\firstpageheader{}{}{}
\runningheader{\class}{\examnum\ - Страница \thepage\ из \numpages}{\examdate}
\runningheadrule

\providecommand{\abs}[1]{\left\lvert{#1}\right\rvert}

\renewcommand{\solutiontitle}{}

\makeatletter
\newcommand{\iftoggleverb}[1]{%
  \ifcsdef{etb@tgl@#1}
    {\csname etb@tgl@#1\endcsname\iftrue\iffalse}
    {\etb@noglobal\etb@err@notoggle{#1}\iffalse}%
}
\makeatother


\begin{document}

\noindent
\begin{tabular*}{\textwidth}{l @{\extracolsep{\fill}} r @{\extracolsep{6pt}} l}
\textbf{\class} & \textbf{Студент:} & \makebox[3in]{\hrulefill}\\
\textbf{\term} &&\\
\textbf{\examnum} &&\\
\textbf{\examdate} \\
\textbf{\timelimit}
\end{tabular*}\\
\rule[2ex]{\textwidth}{2pt}%
\begin{center}
Оценки (заполняется преверяющими)\\
\addpoints
\gradetable[h][questions]
\end{center}
\noindent
\rule[2ex]{\textwidth}{2pt}

\begin{questions}


\question[7] Отметьте только {\bf верные} утверждения из этого списка. Обосновывать свой выбор не требуется.
\begin{checkboxes}
    \iftoggle{first}{%
      \choice $\log{n} + \sqrt{n\sqrt{n}} \in \Theta(\log{n})$
      \begin{solution}
      $\sqrt{n\sqrt{n}} = n^{3/4}$ растёт быстрее чем $\log{n}$:
      $$
      \lim_{n\to\infty} \frac{\log{n}}{n^{3/4}}
      = \lim_{n\to\infty} \frac{(\log{n})'}{(n^{3/4})'}
      = \lim_{n\to\infty} \frac{4}{3} \frac{n^{\frac{1}{4}}}{n} = 0 
      $$
      А значит $\log{n} + \sqrt{n\sqrt{n}} \in O(\sqrt{n\sqrt{n}})$, и уж точно не $\Theta(\log{n})$
      \end{solution}
    }{%
      \choice $\forall a, b\in \mathbb{R}^+:~ a^n + n^{b} \in \Theta(a^n)$
      \begin{solution}
      Утверждение неверно при $\abs{a} < 1$
      \end{solution}
    }

    \iftoggle{first}{%
        \CorrectChoice Алгоритм heapsort сортирует массив in-place.
        \begin{solution}
        Действительно, в heapsort массив на месте превращается в max-heap, после чего максимальные элементы последовательно удаляются из кучи и перемещаются в отсортированный суффикс массива.
        \end{solution}
    }{%
        \choice Алгоритм heapsort может отсортировать двусвязный список in-place за $O(n\log n)$.
        \begin{solution}
        Heapsort подразумевает построение бинарной кучи на массиве, причём схема восстановления кучи зависит от быстрого произвольного доступа к элементам массива. В случае со связным списком такое построение нетривиально, и потребует дополнительной памяти и времени.
        \end{solution}
    }

    \iftoggle{first}{%
        \choice В бинарной куче типа min-heap для любого элемента можно найти следующий за ним по порядку за время $O(\log n)$.
        \begin{solution}
        Согласно свойству кучи, min-heap гарантирует только то, что потомки узла будут больше или равны этому узлу, при этом об упорядоченности узлов ничего не говорится. Например, следующее дерево представляет собой min-heap, однако найти для элемента 9 следующий за ним 10 без обхода всего дерева (т.е. за $O(n)$) невозможно.

        \begin{center}
            \begin{tikzpicture}[level distance=1cm,
              level 1/.style={sibling distance=1.5cm},
              level 2/.style={sibling distance=1cm}]
              \node {4}
                child {node {6}
                  child {node {9}}
                  child {node {8}}
                }
                child {node {5}
                child {node {7}}
                  child {node {10}}
                };
            \end{tikzpicture}
        \end{center}
        \end{solution}
    }{%
        \choice В бинарном дереве поиска для любого элемента можно найти предшествующий за ним по порядку за $O(1)$.
        \begin{solution}
        Асимптотика алгоритма {\tt Tree-Predecessor} (см. например CLRS 12.2) ограничена высотой дерева: в поиске предыдущего элемента мы проходим вниз или вверх по пути от корня к листям. Высота бинарного дерева составляет $O(\log n)$, такая же сложность и у алгоритма.
        \end{solution}
    }

    \iftoggle{first}{%
        \CorrectChoice Время добавления элемента в динамический массив может деградировать до $O(n)$.
        \begin{solution}
        Это происходит при отсутствии свободых ячеек в выделеной памяти. Тогда для добавления нового элемента в конец требуется выделить новый массив большей длины и скопировать туда добавленные ранее элементы.
        \end{solution}
    }{%
        \choice Время добавления элемента в красно-чёрное дерево может деградировать до $O(n)$.
        \begin{solution}
        Балансировка дерева после добавления нового элемента (происходящее за время $O(\log n)$) состоит из не более чем $O(\log n)$ константных по времени операций, а значит асимптотика добавления остаётся логарифмической.
        \end{solution}
    }

    \iftoggle{first}{%
        \choice В алгоритме insertion sort замена линейного поиска на бинарный при поиске позиции для добавления элемента в отсортированый префикс улучшает время работы с $O(n^2)$ до $O(n \log n)$.
        \begin{solution}
        Хоть бинарный поиск потенциально уменьшает абсолютное число операций сравнения, он не улучшает асимптотическую сложность т.к. потребуется ещё освободить место в префиксе для каждого нового элемента, и это по-прежнему линейная операция.
        \end{solution}
    }{%
        \CorrectChoice Массив размера $n$, где элементы принимают всего 3 различных значения, можно отсортировать за $O(n)$
        \begin{solution}
        Это \href{https://en.wikipedia.org/wiki/Dutch_national_flag_problem}{задача о голландском флаге} из задачи 5 третьего задания. Такой алгоритм можно построить с помощью двух вызовов функции {\tt partition} из алгоритма Quicksort.
        \end{solution}
    }


    \iftoggle{first}{%
        \choice В заполненном бинарном дереве из $n$ элементов можно найти элемент за время $O(\log n)$ с помощью обхода в ширину.
        \begin{solution}
        Пусть нам требуется найти значение находящееся в листе сбалансированного дерева. Алгоритм обхода в ширину переходит к узлам глубины $i$ только после посещения узлов на глубине $i-1$, а значит до листьев (т.е., в данном случае, узлов с максимальной глубиной) он доберётся не ранее чем обойдёт порядка $n/2$ элементов дерева, что асимптотически больше чем $O(\log n)$.
        \end{solution}
    }{%
        \choice Поиск минимального элемента в бинарном дереве поиска занимает $O(1)$
        \begin{solution}
        Алгоритм поиска минимума состоит в проходе по левым рёбрам от корня до листа, который и будет минимумом. Число операций в худшем случае при этом пропорционально высоте дерева, т.е. $O(\log n)$ для сбалансированного дерева 
        \end{solution}
    }

    
    \iftoggle{first}{%
        \CorrectChoice Печать $n$ элементов бинарного дерева поиска в отсортированном порядке занимает время $O(n\log n)$
        \begin{solution}
        Сделать это можно с помощью in-order обхода, который занимает время пропорцинальное числу вершин дерева. При этом $n \in O(n\log n)$, что является не строгой, но технически верной асимптотической оценкой.
        \end{solution}
    }{%
        \CorrectChoice Имея неотсортированный массив, построение max-heap из его элементов асимптотически быстрее построения из них же красно-чёрного дерева.
        \begin{solution}
        Построить max-heap можно за $O(n)$, тогда как красно-чёрное дерево -- за $O(\log n)$.
        \end{solution}
    }
\end{checkboxes}


\question[3]
Вы – администратор очереди в Apple Store за новыми айфонами. Покупателям в очереди строго запрещается произносить слово «андроид». Каждого, кто его произнесёт, возвращают в конец очереди. При этом местоположение нарушителя можно определить лишь с точностью до трех человек.

Вы должны обрабатывать запросы:
\begin{itemize}
\item <<Следующий, пожалуйста>>
\item <<Лови андроидофила!>> (после чего вы переставляете подозреваемого и двух его соседей в конец очереди)
\end{itemize}

Какой структурой данных стоит воспользоваться, чтобы за минимальное время и с минимальным потреблением памяти обрабатывать такие запросы? Объясните свой выбор.

\begin{solutionordottedlines}[24em]
Лучше всего для этого подходит двусвязный список:
\begin{itemize}
    \item Запрос <<Следующий, пожалуйста>>, то есть удаление элемента с одного конца, а равно и добавление нарушителей в другой конец, происходит за $O(1)$
    \item Если предположить что определив подозреваемого мы знаем и соответствующий  ему элемент двусвязного списка, удаление его вместе с соседями из середины и перенос в конец очереди тоже выполняется за $O(1)$.
    \item ...а можно и не делать такого предположения, а явно добавить хэш-таблицу, в которой будет храниться соответствие между людьми и элементами списка. Поддержание такой таблицы в актуальном состоянии не повлияет на асимптотику запросов.
\end{itemize}

Очевидно, стек и очередь не подходят для этой задачи, поскольку не допускают операций с элементами в середине.

За предложение использовать динамический массив я ставил минимальный ненулевой балл. Ответ мог бы сойти за корректный, если бы вы объяснили как реализовать <<удаление>> людей из очереди за $O(1)$, пусть и с дополнительными затратами по памяти.
\end{solutionordottedlines}


\question[5] \iftoggle{first}{%
        Перечислите {\bf все} бинарные деревья, в которых порядок обхода узлов совпадает при обходах
        \noaddpoints
        \begin{parts}
        \part[3] preorder и inorder
        \part[1] preorder и postorder
        \part[1] inorder и postorder
        \end{parts}
        \addpoints
        Считать что в бинарных деревьях нет повторяющихся элементов
    }{%
        Докажите или опровергните утверждение: относительный порядок посещения {\em листьев} бинарного дерева при in-, pre- и postorder обходах один и тот же.
    }

\begin{solutionorbox}[\fill]
\iftoggleverb{first}
    \begin{enumerate}
        \item[(a)] Любые бинарные деревья без левых ребёр:
        \begin{center}
            \begin{tikzpicture}[level distance=1cm,
              level 1/.style={sibling distance=1.5cm},
              level 2/.style={sibling distance=1cm}]
              \node[draw,circle] {}
                child[missing]
                child {
                  node[draw,circle] {}
                  child[missing]
                  child {
                    node {$\cdots$}
                    child[missing]
                    child {node[draw,circle] {}}
                  }
                };
            \end{tikzpicture}
        \end{center}
        \item[(b)] Бинарное дерево только с одним узлом и пустое дерево.
        \item[(c)] Любые бинарные деревья без правых ребёр.
    \end{enumerate}
\else
    Обратите внимание: в задаче нас интересует порядок обхода {\em листьев} (узлов без потомков), а не всех узлов в дереве.

    Доказательство методом математической индукции по высоте дерева $h$:
    \begin{itemize}
        \item Для $h=1$ утверждение верно: в дереве два листа, в каждом из обходов сначала посещается левый лист, потом правый.
        \item Предположим, что оно верно и для дерева с $h=n-1$.
        \item Докажем, что тогда утверждение выполняется и для $h=n$. Такое дерево можно представить как:
        \input{tree_02_03}
        В каждом из обходов будет посещено сначала левое поддерево, потом правое. По предположению выше, в каждом из них порядок обхода листьев фиксирован. Значит он фиксирован и для обхода всего дерева.
    \end{itemize}    
\fi
\end{solutionorbox}
\newpage

\question[10] Для некоторого конечного множества неотрицательных чисел, рассматривая их двоичные представления как слова алфавите $\{0, 1\}$, можно построить префиксное дерево. Такое дерево будет бинарным, при этом условимся считать левое ребро соответствующим <<0>>, а правое -- <<1>>.
\noaddpoints
\begin{parts}
\part[5] Постройте такое префиксное дерево для чисел %
    \iftoggle{first}{$\{8, 12, 15\}$}{$\{10, 11, 12\}$}.
\part[1] Пронумеруйте его вершины в порядке обхода в ширину.
\part[3] Выполните \iftoggle{first}{левый поворот}{правый поворот} относительно узла под \mbox{номером} 2.
\part[1] Выпишите множество десятичных чисел, которое соответствует получившемуся в результате префиксному дереву.
\end{parts}
\addpoints

\begin{solutionorbox}[\fill]
    a) \iftoggle{first}{
        Числа $\{8, 12, 15\}$ соответствуют $\{1000, 1100, 1111\}$ в двоичной системе.
    }{
        Числа $\{10, 11, 12\}$ соответствуют $\{1010, 1011, 1100\}$ в двоичной системе.
    }
    Строим для них префиксное дерево откладывая левое ребро для каждого <<0>> и правое для каждой <<1>>, выделяем терминальные листья.
    \input{tree_\iftoggle{first}{01}{02}_04a}
    b) Нумеруем узлы по уровням:
    \input{tree_\iftoggle{first}{01}{02}_04b}
    c) Поворот:
    \input{tree_\iftoggle{first}{01}{02}_04c}
    d) Восстанавливаем новое множество чисел: на путях от корня до помеченных ранее листьев выписываем <<1>> при переходе по правому ребру и <<0>> по левому:
    \iftoggle{first}{
        $\{10000, 1010, 111\}$, т.е. $\{16, 10, 7\}$.
    }{
        $\{11100, 1100, 1101\}$, т.е. $\{28, 12, 13\}$.
    }
\end{solutionorbox}
\newpage

\question[10] 
%
\iftoggle{first}{%
  Опишите (подробным текстом или с помощью псевдокода) алгоритм, который переставляет элементы в массиве целых чисел так, чтобы отрицательные числа предшествовали неотрицательным. Алгоритм должен работать in-place (т.е. без выделения дополнительного массива) и иметь минимально возможную вычислительную сложность.
}{%
  В алгоритме mergesort два отсортированных массива <<сливаются>> в один отсортированный. Опишите (подробным текстом или с помощью псевдокода) алгоритм слияния $k$ отсортированных массивов в один отсортированный за время $O(n \log k)$. {\em Подсказка:} вам потребуется дополнительная структура данных, которая используется в одном из изученных алгоритмов сортировки.
}
\begin{solutionorbox}[\fill]

    Минимально необходимое описание алгоритма могло выглядеть так:
    \iftoggleverb{first}
        \begin{itemize}
            \item В задаче требуется лишь отделить отрицательные числа от неотрицательных, а не сортировать их полностью. Для этого достаточно один раз вызвать функцию {\tt partition} из алгоритма Quicksort, взяв в качестве опорного элемента <<0>>.
        \end{itemize}

        На практике, в оригинальной функции потребуются минимальные изменения: явно задать значение {\tt pivot} и поменять знак сравнения на строгий:
        \begin{alltt}
        def partition(A):
            pivot = 0
            i = 0
            
            for j in range(0, len(A)):
                if A[j] < pivot:
                    A[i], A[j] = A[j], A[i]
                    i += 1
            return i
        \end{alltt}
    \else
        \begin{enumerate}
            \item[0.] Создаём пустой min-heap. Заводим на каждый массив по итератору, извлекаем из каждого первый элемент и добавляем в min-heap.
            \item\label{begin} Извлекаем минимальный элемент из min-heap, добавляем его к массиву результата. Из массива, откуда пришёл этот элемент, достаём следующий, и добавляем в min-heap.
            \item Повторяем пункт \ref{begin}. пока по всех массивах не кончатся элементы.
        \end{enumerate}
    \fi
\end{solutionorbox}
\newpage

\question[10] %
\iftoggleverb{first}
    Напишите на Python рекурсивную функцию, которая возвращает количество листьев в данном бинарном дереве.
    \begin{solutionorbox}[\fill]
        \begin{alltt}
        def n_leaves(node):
            if node is None:
                return 0
            if node.left is node.right is None:
                return 1
            return n_leaves(node.left) + n_leaves(node.right)
        \end{alltt}
    \end{solutionorbox}
\else
Напишите на Python рекурсивную функцию, которая возвращает максимальную сумму значений узлов на пути от корня до листьев.
    \begin{solutionorbox}[\fill]
        \begin{alltt}
        def max_path(node):
            if node is None:
                return 0
            return node.value + max(
                max_path(node.left),
                max_path(node.right)
            )
        \end{alltt}
    \end{solutionorbox}
\fi



\end{questions}

\end{document}
